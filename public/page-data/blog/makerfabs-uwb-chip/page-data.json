{
    "componentChunkName": "component---node-modules-gatsby-theme-advanced-src-templates-post-query-ts",
    "path": "/blog/makerfabs-uwb-chip",
    "result": {"data":{"mdx":{"body":"var _excluded = [\"components\"];\n\nfunction _extends() { _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\n\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\n\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n\n/* @jsxRuntime classic */\n\n/* @jsx mdx */\nvar _frontmatter = {\n  \"title\": \"Makerfabs UWB Chip\",\n  \"cover\": \"images/ESP32-UWB-Ultra-Wideband-1000x750.jpg\",\n  \"coverAlt\": \"Makerfabs UWB chip\",\n  \"description\": \"Ultra-wideband (UWB) is a short-range, wireless communication protocol that operates through radio waves, enables secure reliable ranging and precision sensing, creating a new dimension of spatial context for wireless devices.\",\n  \"category\": \"tech\",\n  \"datePublished\": \"2022-01-11\",\n  \"dateModified\": \"2022-01-11\",\n  \"tags\": [\"programming\", \"uwb\", \"testing\"]\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n      props = _objectWithoutProperties(_ref, _excluded);\n\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"h2\", null, \"ESP32 UWB(Ultra Wideband)\"), mdx(\"p\", null, \"Ultra-wideband (UWB) is a short-range, wireless communication protocol that operates through radio waves, enables secure reliable ranging and precision sensing, creating a new dimension of spatial context for wireless devices.\"), mdx(\"p\", null, \"Makerfabs ESP32 UWB module is based on DW1000, it acts like a continuously scanning radar, that precisely locks onto another device (called Anchor) and communicates with it, thus calculating its own location. Once the device is near another UWB device, the devices start \\u201Cranging.\\u201D Ranging refers to calculating the time of flight (ToF) between devices: the roundtrip time of challenge/response packets.\"), mdx(\"p\", null, \"Features:\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Decawave DWM1000 for precision tracking\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"ESP32 for fast & powerful applications\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Support Wifi, Bluetooth\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Arduino compatible\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Micro-USB connector\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Board USB supply voltage range: 4.8~5.5V, 5.0V Typical\")), mdx(\"p\", null, \"1.2 About UWB\\nUltra-wideband is a technology for transmitting information across a wide bandwidth (>500 MHz). This allows for the transmission of a large amount of signal energy without interfering with conventional narrowband and carrier wave transmission in the same frequency band. Regulatory limits in many countries allow for this efficient use of radio bandwidth, and enable high-data-rate personal area network (PAN) wireless connectivity, longer-range low-data-rate applications, and radar and imaging systems, coexisting transparently with existing communications systems.\\nAbout-UWB-Bandwidth\\nA significant difference between conventional radio transmissions and UWB is that conventional systems transmit information by varying the power level, frequency, and/or phase of a sinusoidal wave. UWB transmissions transmit information by generating radio energy at specific time intervals and occupying a large bandwidth, thus enabling pulse-position or time modulation. The information can also be modulated on UWB signals (pulses) by encoding the polarity of the pulse, its amplitude and/or by using orthogonal pulses. UWB pulses can be sent sporadically at relatively low pulse rates to support time or position modulation, but can also be sent at rates up to the inverse of the UWB pulse bandwidth. Pulse-UWB systems have been demonstrated at channel pulse rates in excess of 1.3 billion pulses per second using a continuous stream of UWB pulses (Continuous Pulse UWB or C-UWB), while supporting forward error-correction encoded data rates in excess of 675 Mbit/s.\\n1.3 UWB Ranging\\nA UWB radio system can be used to determine the \\\"time of flight\\\" of the transmission at various frequencies. Of course, the speed of the \\\"flight\\\" is as that of light, so the core problem is how to check the \\\"flight\\\" time, and thus to calculate the distance.\"), mdx(\"p\", null, \"Distance =Speed of light * Tprot\"), mdx(\"p\", null, \"For the most basic system, there at least 2 items: Device_A(called A) and Device_B(called B),  there mainly 2 measure way:\"), mdx(\"ol\", null, mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"Single-sided Two-way Ranging\"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"Double-sided Two-way Ranging\\n1.3.1 Single-sided Two-way Ranging\\nThis is the most basic way of measuring:\\nSingle-Sided-Two-Way-Ranging\\nFirstly A send the message(TX) and have a record of the time Mark, As B get the message, and have the recode of time Mark, after delay(Treplay), B send the message (TX) and have a record of the time mark, and finally A receive the message, and have the record of time mark.\")), mdx(\"p\", null, \"Then the flight time:\\nFlight-Time\"), mdx(\"p\", null, \"As the Tround and Treply are stored at the same device, so the time-error offset; of course there error between A(eA) and B(eB), and the error is:\\nError\"), mdx(\"p\", null, \"That is, the error is linear to the Treply. So this way is not popular used, only suit for very short distance measuring.\\n1.3.2 Double-sided Two-way Ranging\\nAfter the \\\"Single-sided Two-way Ranging\\\", if A feedback again to B, it will be :\\nDouble-sided-Two-way-Ranging-3-Messages-Mode\\nThis measurement we called 3 messages mode.\"), mdx(\"p\", null, \"After the \\\"Single-sided Two-way Ranging\\\", if B initiate again another message and A feedback, it will be :\\nDouble-Sided-Two-Way-Ranging-4-Messages-Mode\\nThis measurement we called 4 messages mode.\"), mdx(\"p\", null, \"In either 3-message mode or 4-message mode, the flight time is calculated as:\\nFlight-Time-3-Message-Mode\\nESP32-UWB-Distance\\n2. Indoor Positioning with ESP32 UWB\\n2.1 View\\nIn this application, we used 3 Makerfabs ESP32 UWB module, 2 module act as the UWB anchor, and 1 as the UWB tag, that moves in the room. As the tag gets its position, it transmit its location to devices(either PC browser, of app at phone), to show the real-time position.\\nESP32-UWB-Indoor-Positioning-Schematic\\n2.2 Plane orientation algorithm\\nAssume that all three UWB modules are at the same horizontal height. UWB can get the distance between Tag and two anchors, plus the distance of two anchors set in advance, we can get the length of three sides of a triangle.\\nTriangle\\nTwo points \\\"AB\\\" are two anchors respectively, and \\\"C\\\" is the point of tag. \\\"c\\\" is the distance of two anchors, and UWB will get two lengths \\\"a\\\" and \\\"b\\\". Tag is \\\"b\\\" away from point \\\"A\\\" and \\\"a\\\" away from point \\\"B\\\".\\nNow that we know the distance between the three sides of the triangle, we can calculate the coordinates of point \\\"C\\\".\"), mdx(\"p\", null, \"I used the law of cosines to calculate the cosine of Angle \\\"A\\\":\\nCosine-of-Angle-A\\nI have the Pythagorean Theorem that gives me the sine of Angle \\\"A\\\":\\nPythagorean-Theorem\\ncos_a = (b \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \" b + c \"), \" c - a \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \" a) / (2 \"), \" b \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \" c)\\nsin_a = sqrt(1 - cos_a \"), \" cos_a)\"), mdx(\"p\", null, \"If we set point \\\"A\\\" as the origin of the coordinate system (0,0), then we get point C (bcos\\u03B1, bsin\\u03B1).\\n3. Equipment List\\n\\u25CF ESP32 UWB \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"3\\n\\u25CF Power bank\\n\\u25CF 5v power supply \"), \"2\\n4. Code Explain\\n4.1 Library\\nWe use arduino-dw1000 library. A library that offers basic functionality to use Decawave's DW1000 chips/modules with Arduino.(arduino-dw1000 library)\"), mdx(\"p\", null, \"Please Note to modify the DW1000 library according to Github, otherwise it will not compile for ESP32. The guide at ESP32 UWB GitHub\"), mdx(\"p\", null, mdx(\"strong\", {\n    parentName: \"p\"\n  }, mdx(\"em\", {\n    parentName: \"strong\"\n  }, \"The full code for this application at: Makerfabs GitHub\")), \"\\n4.2 Device_Anchor\\nAs there 2 anchors in the system, we need to set different anchor addresses for the two anchors.\\n#define ANCHOR_ADD \\\"83:17:5B:D5:A9:9A:E2:9C\\\"// modify the address when multiple anchors, such as 83/82.\\nThe library uses random short addresses by default, and we need to set it to use the static addresses we set. So we need to set the UWB module to Anchor mode, LONGDATA_RANGE_LOWPOWER mode and turn off random short address, by the following code:\\nDW1000Ranging.startAsAnchor(ANCHOR_ADD,\\nDW1000.MODE_LONGDATA_RANGE_LOWPOWER, false);\\nThe Anchor code at: \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://github.com/Makerfabs/Makerfabs-ESP32-UWB/tree/main/example/anchor\",\n    \"target\": \"_blank\",\n    \"rel\": \"nofollow noopener noreferrer\"\n  }, \"https://github.com/Makerfabs/Makerfabs-ESP32-UWB/tree/main/example/anchor\"), \"\\n4.3 Device_Tag\\nTag needs to read the distance between the two anchors and send it to PC through UDP protocol.\"), mdx(\"p\", null, \"Firstly, set WiFi and target IP address (PC).\\nSet-WiFi-and-Target-IP-Address\"), mdx(\"p\", null, \"In Windows cmd, using \\\"ipconfig\\\" to check PC local IP.\\nCheck-PC-Local-IP\"), mdx(\"p\", null, \"And set UWB work in tag mode.\\nSet-UWB-Work-in-Tag-Mode\"), mdx(\"p\", null, \"I used a Linked list to store the detected anchors, which fits well with the way UWB works. The content of the linked list is converted into JSON format.\"), mdx(\"p\", null, \"The obtained JSON string format is as follows:\\nObtained-JSON-String-Format\"), mdx(\"p\", null, \"Finally, data is sent to PC every second through UDP protocol.\\nData-is-Sent-to-PC-Every-Second\"), mdx(\"p\", null, \"The tag code at: \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://github.com/Makerfabs/Makerfabs-ESP32-UWB/tree/main/example/IndoorPositioning/udp_uwb_tag\",\n    \"target\": \"_blank\",\n    \"rel\": \"nofollow noopener noreferrer\"\n  }, \"https://github.com/Makerfabs/Makerfabs-ESP32-UWB/tree/main/example/IndoorPositioning/udp_uwb_tag\"), \"\\n4.4 Python Code\\nA simple demo to calculate the position of the tag and graphically display it. Using turtle to draw.\"), mdx(\"p\", null, \"In the beginning I wanted to use Matplotlib, but it was a bit complicated. Turtle is easy, but the functions provided are rudimentary. I added some drawing functions myself to quickly draw lines, circles, rectangles, etc.\\nGraphically-Display-of-the-UWB-Tag\"), mdx(\"p\", null, \"Here is my position calculation function.\\nPosition-Calculation-Function\"), mdx(\"p\", null, \"In fact, at first I used Helen's formula to calculate the coordinates, but couldn't tell whether a triangle was acute or obtuse.\"), mdx(\"p\", null, \"The function of demo is to receive the data of tag transmitted through UDP protocol, calculate the position of tag and draw it on the screen.\\n5. Test\\nAfter all the UWB anchors& tag programmed OK, firstly I place the two UWB anchors on both sides of the table.\\nESP32-UWB-Indoor-Positioning-Test-1\"), mdx(\"p\", null, \"And run the Python program on the PC side. Attach the UWB tag to the power bank and wait for it to connect to the WiFi in the room. After the Tag is connected to the PC, the graphical interface pops up.\\nUWB-Position-Graphical-Display\"), mdx(\"p\", null, \"Move the UWB tag around, the tag position can be real-time monitored at the PC:\\nESP32-UWB-Indoor-Positioning-Test-2ESP32-UWB-Indoor-Positioning-Test-3\"), mdx(\"p\", null, \"Check the video:\"), mdx(\"p\", null, \"If you have further questions for this application about ESP32 UWB Indoor Positioning, or need some customized PCB assembly service, please contact \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"mailto:service@makerfabs.com.wink\"\n  }, \"service@makerfabs.com.wink\")));\n}\n;\nMDXContent.isMDXComponent = true;","timeToRead":5,"excerpt":"ESP32 UWB(Ultra Wideband) Ultra-wideband (UWB) is a short-range, wireless communication protocol that operates through radio waves, enables…","frontmatter":{"title":"Makerfabs UWB Chip","description":"Ultra-wideband (UWB) is a short-range, wireless communication protocol that operates through radio waves, enables secure reliable ranging and precision sensing, creating a new dimension of spatial context for wireless devices.","cover":{"publicURL":"/static/48904c6b1cfbc7789769414ca3e8041f/ESP32-UWB-Ultra-Wideband-1000x750.jpg","childImageSharp":{"gatsbyImageData":{"layout":"constrained","placeholder":{"fallback":"data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAAPABQDASIAAhEBAxEB/8QAFwABAQEBAAAAAAAAAAAAAAAAAAQCBf/EABUBAQEAAAAAAAAAAAAAAAAAAAEC/9oADAMBAAIQAxAAAAHtx1ZKoDP/xAAZEAADAQEBAAAAAAAAAAAAAAABAgMAEhP/2gAIAQEAAQUCduROxLaqeiSnyN//xAAWEQADAAAAAAAAAAAAAAAAAAAQESH/2gAIAQMBAT8BiH//xAAUEQEAAAAAAAAAAAAAAAAAAAAQ/9oACAECAQE/AT//xAAcEAABAwUAAAAAAAAAAAAAAAARAAIQEiEiMVH/2gAIAQEABj8CQ3FJCyu7sf/EABsQAAICAwEAAAAAAAAAAAAAAAERIUEAEGFx/9oACAEBAAE/IZG8r40iJHdNG+MNOFmn/9oADAMBAAIAAwAAABC7z//EABcRAAMBAAAAAAAAAAAAAAAAAAEQETH/2gAIAQMBAT8QEUdX/8QAFhEAAwAAAAAAAAAAAAAAAAAAEBEh/9oACAECAQE/EKx//8QAHhABAAEDBQEAAAAAAAAAAAAAARExQWEAECFRcdH/2gAIAQEAAT8QnzEuCaGXBXQFLykULSz182cySjN0WcaFrNmo9BPm3//Z"},"backgroundColor":"transparent","images":{"fallback":{"src":"/static/48904c6b1cfbc7789769414ca3e8041f/663f8/ESP32-UWB-Ultra-Wideband-1000x750.jpg","srcSet":"/static/48904c6b1cfbc7789769414ca3e8041f/c547d/ESP32-UWB-Ultra-Wideband-1000x750.jpg 250w,\n/static/48904c6b1cfbc7789769414ca3e8041f/1ad3f/ESP32-UWB-Ultra-Wideband-1000x750.jpg 500w,\n/static/48904c6b1cfbc7789769414ca3e8041f/663f8/ESP32-UWB-Ultra-Wideband-1000x750.jpg 1000w","sizes":"(min-width: 1000px) 1000px, 100vw"},"sources":[{"srcSet":"/static/48904c6b1cfbc7789769414ca3e8041f/e8c96/ESP32-UWB-Ultra-Wideband-1000x750.avif 250w,\n/static/48904c6b1cfbc7789769414ca3e8041f/cd736/ESP32-UWB-Ultra-Wideband-1000x750.avif 500w,\n/static/48904c6b1cfbc7789769414ca3e8041f/d321b/ESP32-UWB-Ultra-Wideband-1000x750.avif 1000w","type":"image/avif","sizes":"(min-width: 1000px) 1000px, 100vw"},{"srcSet":"/static/48904c6b1cfbc7789769414ca3e8041f/b8ed9/ESP32-UWB-Ultra-Wideband-1000x750.webp 250w,\n/static/48904c6b1cfbc7789769414ca3e8041f/28965/ESP32-UWB-Ultra-Wideband-1000x750.webp 500w,\n/static/48904c6b1cfbc7789769414ca3e8041f/a80f4/ESP32-UWB-Ultra-Wideband-1000x750.webp 1000w","type":"image/webp","sizes":"(min-width: 1000px) 1000px, 100vw"}]},"width":1000,"height":750}}},"coverAlt":"Makerfabs UWB chip","datePublished":"2022-01-11","dateModified":"2022-01-11","category":"tech","tags":["programming","uwb","testing"]},"fields":{"slug":"/makerfabs-uwb-chip","route":"/blog/makerfabs-uwb-chip","pathName":"blog/makerfabs-uwb-chip","url":"https://zobo.dev/blog/makerfabs-uwb-chip"},"internal":{"content":"---\ntitle: \"Makerfabs UWB Chip\"\ncover: images/ESP32-UWB-Ultra-Wideband-1000x750.jpg\ncoverAlt: \"Makerfabs UWB chip\"\ndescription: \"Ultra-wideband (UWB) is a short-range, wireless communication protocol that operates through radio waves, enables secure reliable ranging and precision sensing, creating a new dimension of spatial context for wireless devices.\"\ncategory: \"tech\"\ndatePublished: \"2022-01-11\"\ndateModified: \"2022-01-11\"\ntags:\n  - programming\n  - uwb\n  - testing \n---\n\n\n## ESP32 UWB(Ultra Wideband)\n\nUltra-wideband (UWB) is a short-range, wireless communication protocol that operates through radio waves, enables secure reliable ranging and precision sensing, creating a new dimension of spatial context for wireless devices.\n\nMakerfabs ESP32 UWB module is based on DW1000, it acts like a continuously scanning radar, that precisely locks onto another device (called Anchor) and communicates with it, thus calculating its own location. Once the device is near another UWB device, the devices start “ranging.” Ranging refers to calculating the time of flight (ToF) between devices: the roundtrip time of challenge/response packets.\n\nFeatures:\n\n* Decawave DWM1000 for precision tracking\n* ESP32 for fast & powerful applications\n* Support Wifi, Bluetooth\n* Arduino compatible\n* Micro-USB connector\n* Board USB supply voltage range: 4.8~5.5V, 5.0V Typical\n\n\n1.2 About UWB\nUltra-wideband is a technology for transmitting information across a wide bandwidth (>500 MHz). This allows for the transmission of a large amount of signal energy without interfering with conventional narrowband and carrier wave transmission in the same frequency band. Regulatory limits in many countries allow for this efficient use of radio bandwidth, and enable high-data-rate personal area network (PAN) wireless connectivity, longer-range low-data-rate applications, and radar and imaging systems, coexisting transparently with existing communications systems.\nAbout-UWB-Bandwidth\nA significant difference between conventional radio transmissions and UWB is that conventional systems transmit information by varying the power level, frequency, and/or phase of a sinusoidal wave. UWB transmissions transmit information by generating radio energy at specific time intervals and occupying a large bandwidth, thus enabling pulse-position or time modulation. The information can also be modulated on UWB signals (pulses) by encoding the polarity of the pulse, its amplitude and/or by using orthogonal pulses. UWB pulses can be sent sporadically at relatively low pulse rates to support time or position modulation, but can also be sent at rates up to the inverse of the UWB pulse bandwidth. Pulse-UWB systems have been demonstrated at channel pulse rates in excess of 1.3 billion pulses per second using a continuous stream of UWB pulses (Continuous Pulse UWB or C-UWB), while supporting forward error-correction encoded data rates in excess of 675 Mbit/s.\n1.3 UWB Ranging\nA UWB radio system can be used to determine the \"time of flight\" of the transmission at various frequencies. Of course, the speed of the \"flight\" is as that of light, so the core problem is how to check the \"flight\" time, and thus to calculate the distance.\n\nDistance =Speed of light * Tprot\n\nFor the most basic system, there at least 2 items: Device_A(called A) and Device_B(called B),  there mainly 2 measure way:\n1. Single-sided Two-way Ranging\n2. Double-sided Two-way Ranging\n1.3.1 Single-sided Two-way Ranging\nThis is the most basic way of measuring:\nSingle-Sided-Two-Way-Ranging\nFirstly A send the message(TX) and have a record of the time Mark, As B get the message, and have the recode of time Mark, after delay(Treplay), B send the message (TX) and have a record of the time mark, and finally A receive the message, and have the record of time mark.\n\nThen the flight time:\nFlight-Time\n\nAs the Tround and Treply are stored at the same device, so the time-error offset; of course there error between A(eA) and B(eB), and the error is:\nError\n\nThat is, the error is linear to the Treply. So this way is not popular used, only suit for very short distance measuring.\n1.3.2 Double-sided Two-way Ranging\nAfter the \"Single-sided Two-way Ranging\", if A feedback again to B, it will be :\nDouble-sided-Two-way-Ranging-3-Messages-Mode\nThis measurement we called 3 messages mode.\n\nAfter the \"Single-sided Two-way Ranging\", if B initiate again another message and A feedback, it will be :\nDouble-Sided-Two-Way-Ranging-4-Messages-Mode\nThis measurement we called 4 messages mode.\n\nIn either 3-message mode or 4-message mode, the flight time is calculated as:\nFlight-Time-3-Message-Mode\nESP32-UWB-Distance\n2. Indoor Positioning with ESP32 UWB\n2.1 View\nIn this application, we used 3 Makerfabs ESP32 UWB module, 2 module act as the UWB anchor, and 1 as the UWB tag, that moves in the room. As the tag gets its position, it transmit its location to devices(either PC browser, of app at phone), to show the real-time position.\nESP32-UWB-Indoor-Positioning-Schematic\n2.2 Plane orientation algorithm\nAssume that all three UWB modules are at the same horizontal height. UWB can get the distance between Tag and two anchors, plus the distance of two anchors set in advance, we can get the length of three sides of a triangle.\nTriangle\nTwo points \"AB\" are two anchors respectively, and \"C\" is the point of tag. \"c\" is the distance of two anchors, and UWB will get two lengths \"a\" and \"b\". Tag is \"b\" away from point \"A\" and \"a\" away from point \"B\".\nNow that we know the distance between the three sides of the triangle, we can calculate the coordinates of point \"C\".\n\nI used the law of cosines to calculate the cosine of Angle \"A\":\nCosine-of-Angle-A\nI have the Pythagorean Theorem that gives me the sine of Angle \"A\":\nPythagorean-Theorem\ncos_a = (b * b + c * c - a * a) / (2 * b * c)\nsin_a = sqrt(1 - cos_a * cos_a)\n\nIf we set point \"A\" as the origin of the coordinate system (0,0), then we get point C (bcosα, bsinα).\n3. Equipment List\n● ESP32 UWB *3\n● Power bank\n● 5v power supply *2\n4. Code Explain\n4.1 Library\nWe use arduino-dw1000 library. A library that offers basic functionality to use Decawave's DW1000 chips/modules with Arduino.(arduino-dw1000 library)\n\nPlease Note to modify the DW1000 library according to Github, otherwise it will not compile for ESP32. The guide at ESP32 UWB GitHub\n\n***The full code for this application at: Makerfabs GitHub***\n4.2 Device_Anchor\nAs there 2 anchors in the system, we need to set different anchor addresses for the two anchors.\n#define ANCHOR_ADD \"83:17:5B:D5:A9:9A:E2:9C\"// modify the address when multiple anchors, such as 83/82.\nThe library uses random short addresses by default, and we need to set it to use the static addresses we set. So we need to set the UWB module to Anchor mode, LONGDATA_RANGE_LOWPOWER mode and turn off random short address, by the following code:\nDW1000Ranging.startAsAnchor(ANCHOR_ADD,\nDW1000.MODE_LONGDATA_RANGE_LOWPOWER, false);\nThe Anchor code at: https://github.com/Makerfabs/Makerfabs-ESP32-UWB/tree/main/example/anchor\n4.3 Device_Tag\nTag needs to read the distance between the two anchors and send it to PC through UDP protocol.\n\nFirstly, set WiFi and target IP address (PC).\nSet-WiFi-and-Target-IP-Address\n\nIn Windows cmd, using \"ipconfig\" to check PC local IP.\nCheck-PC-Local-IP\n\nAnd set UWB work in tag mode.\nSet-UWB-Work-in-Tag-Mode\n\nI used a Linked list to store the detected anchors, which fits well with the way UWB works. The content of the linked list is converted into JSON format.\n\nThe obtained JSON string format is as follows:\nObtained-JSON-String-Format\n\nFinally, data is sent to PC every second through UDP protocol.\nData-is-Sent-to-PC-Every-Second\n\nThe tag code at: https://github.com/Makerfabs/Makerfabs-ESP32-UWB/tree/main/example/IndoorPositioning/udp_uwb_tag\n4.4 Python Code\nA simple demo to calculate the position of the tag and graphically display it. Using turtle to draw.\n\nIn the beginning I wanted to use Matplotlib, but it was a bit complicated. Turtle is easy, but the functions provided are rudimentary. I added some drawing functions myself to quickly draw lines, circles, rectangles, etc.\nGraphically-Display-of-the-UWB-Tag\n\nHere is my position calculation function.\nPosition-Calculation-Function\n\nIn fact, at first I used Helen's formula to calculate the coordinates, but couldn't tell whether a triangle was acute or obtuse.\n\nThe function of demo is to receive the data of tag transmitted through UDP protocol, calculate the position of tag and draw it on the screen.\n5. Test\nAfter all the UWB anchors& tag programmed OK, firstly I place the two UWB anchors on both sides of the table.\nESP32-UWB-Indoor-Positioning-Test-1\n\nAnd run the Python program on the PC side. Attach the UWB tag to the power bank and wait for it to connect to the WiFi in the room. After the Tag is connected to the PC, the graphical interface pops up.\nUWB-Position-Graphical-Display\n\nMove the UWB tag around, the tag position can be real-time monitored at the PC:\nESP32-UWB-Indoor-Positioning-Test-2ESP32-UWB-Indoor-Positioning-Test-3\n\nCheck the video:\n\nIf you have further questions for this application about ESP32 UWB Indoor Positioning, or need some customized PCB assembly service, please contact service@makerfabs.com.wink"}}},"pageContext":{"slug":"/makerfabs-uwb-chip","nexttitle":"ESP32 UWB Indoor positioning","nextslug":"/esp-32-uwb-indoor-positioning","prevtitle":"Azure Static Web Apps - Step By Step","prevslug":"/azure-static-web-apps-step-by-step","relatedPosts":[{"title":"Makerfabs UWB Chip","description":"Ultra-wideband (UWB) is a short-range, wireless communication protocol that operates through radio waves, enables secure reliable ranging and precision sensing, creating a new dimension of spatial context for wireless devices.","coverImg":{"layout":"constrained","placeholder":{"fallback":"data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAAPABQDASIAAhEBAxEB/8QAFwABAQEBAAAAAAAAAAAAAAAAAAQCBf/EABUBAQEAAAAAAAAAAAAAAAAAAAEC/9oADAMBAAIQAxAAAAHtx1ZKoDP/xAAZEAADAQEBAAAAAAAAAAAAAAABAgMAEhP/2gAIAQEAAQUCduROxLaqeiSnyN//xAAWEQADAAAAAAAAAAAAAAAAAAAQESH/2gAIAQMBAT8BiH//xAAUEQEAAAAAAAAAAAAAAAAAAAAQ/9oACAECAQE/AT//xAAcEAABAwUAAAAAAAAAAAAAAAARAAIQEiEiMVH/2gAIAQEABj8CQ3FJCyu7sf/EABsQAAICAwEAAAAAAAAAAAAAAAERIUEAEGFx/9oACAEBAAE/IZG8r40iJHdNG+MNOFmn/9oADAMBAAIAAwAAABC7z//EABcRAAMBAAAAAAAAAAAAAAAAAAEQETH/2gAIAQMBAT8QEUdX/8QAFhEAAwAAAAAAAAAAAAAAAAAAEBEh/9oACAECAQE/EKx//8QAHhABAAEDBQEAAAAAAAAAAAAAARExQWEAECFRcdH/2gAIAQEAAT8QnzEuCaGXBXQFLykULSz182cySjN0WcaFrNmo9BPm3//Z"},"backgroundColor":"transparent","images":{"fallback":{"src":"/static/48904c6b1cfbc7789769414ca3e8041f/96f36/ESP32-UWB-Ultra-Wideband-1000x750.jpg","srcSet":"/static/48904c6b1cfbc7789769414ca3e8041f/9b14a/ESP32-UWB-Ultra-Wideband-1000x750.jpg 123w,\n/static/48904c6b1cfbc7789769414ca3e8041f/9ff9d/ESP32-UWB-Ultra-Wideband-1000x750.jpg 246w,\n/static/48904c6b1cfbc7789769414ca3e8041f/96f36/ESP32-UWB-Ultra-Wideband-1000x750.jpg 491w,\n/static/48904c6b1cfbc7789769414ca3e8041f/c7f72/ESP32-UWB-Ultra-Wideband-1000x750.jpg 982w","sizes":"(min-width: 491px) 491px, 100vw"},"sources":[{"srcSet":"/static/48904c6b1cfbc7789769414ca3e8041f/11b27/ESP32-UWB-Ultra-Wideband-1000x750.avif 123w,\n/static/48904c6b1cfbc7789769414ca3e8041f/e78e2/ESP32-UWB-Ultra-Wideband-1000x750.avif 246w,\n/static/48904c6b1cfbc7789769414ca3e8041f/9568e/ESP32-UWB-Ultra-Wideband-1000x750.avif 491w,\n/static/48904c6b1cfbc7789769414ca3e8041f/f7af3/ESP32-UWB-Ultra-Wideband-1000x750.avif 982w","type":"image/avif","sizes":"(min-width: 491px) 491px, 100vw"},{"srcSet":"/static/48904c6b1cfbc7789769414ca3e8041f/3adb8/ESP32-UWB-Ultra-Wideband-1000x750.webp 123w,\n/static/48904c6b1cfbc7789769414ca3e8041f/39eb4/ESP32-UWB-Ultra-Wideband-1000x750.webp 246w,\n/static/48904c6b1cfbc7789769414ca3e8041f/f4c74/ESP32-UWB-Ultra-Wideband-1000x750.webp 491w,\n/static/48904c6b1cfbc7789769414ca3e8041f/84ea5/ESP32-UWB-Ultra-Wideband-1000x750.webp 982w","type":"image/webp","sizes":"(min-width: 491px) 491px, 100vw"}]},"width":491,"height":368},"coverImageAlt":"Makerfabs UWB chip","datePublished":"2022-01-11T00:00:00.000Z","dateModified":"2022-01-11T00:00:00.000Z","category":"tech","tags":["programming","uwb","testing"],"excerpt":"ESP32 UWB(Ultra Wideband) Ultra-wideband (UWB) is a short-range, wireless communication protocol that operates through radio waves, enables…","timeToRead":5,"slug":"/makerfabs-uwb-chip","route":"/blog/makerfabs-uwb-chip","pathName":"blog/makerfabs-uwb-chip","url":"https://zobo.dev/blog/makerfabs-uwb-chip"},{"title":"ESP32 UWB Indoor positioning","description":"Ultra-wideband (UWB) is a short-range, wireless communication protocol that operates through radio waves, enables secure reliable ranging and precision sensing, creating a new dimension of spatial context for wireless devices.","coverImg":{"layout":"constrained","placeholder":{"fallback":"data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAAMABQDASIAAhEBAxEB/8QAFwAAAwEAAAAAAAAAAAAAAAAAAAQFA//EABYBAQEBAAAAAAAAAAAAAAAAAAEAAv/aAAwDAQACEAMQAAABXpqbmZJXI//EABoQAAMBAAMAAAAAAAAAAAAAAAABAwISEyP/2gAIAQEAAQUCpt6ISm40Xpk5s7dH/8QAFxEBAQEBAAAAAAAAAAAAAAAAAQACEv/aAAgBAwEBPwF0XZf/xAAVEQEBAAAAAAAAAAAAAAAAAAAAEf/aAAgBAgEBPwFX/8QAGhAAAgIDAAAAAAAAAAAAAAAAAREAAiAxQf/aAAgBAQAGPwIrUqSnLIdw/8QAGxABAAIDAQEAAAAAAAAAAAAAAQARITGRUXH/2gAIAQEAAT8hse91MyoZsI4aUOqIDYV8lnnJRgTk/9oADAMBAAIAAwAAABD87//EABURAQEAAAAAAAAAAAAAAAAAAAEQ/9oACAEDAQE/EBS//8QAFhEBAQEAAAAAAAAAAAAAAAAAADER/9oACAECAQE/EJWH/8QAGxABAAMBAAMAAAAAAAAAAAAAAQARMSFBUWH/2gAIAQEAAT8QoE6B1PJAL9qN39LifJOCr5kIAE3bxZWQMWPmUmMAwpP/2Q=="},"backgroundColor":"transparent","images":{"fallback":{"src":"/static/f70ac99b7fb70463fa0c6ce006ae7b08/7b087/1640138203_ESP32-UWB-Indoor-Positioning-Test-Makerfabs.jpg","srcSet":"/static/f70ac99b7fb70463fa0c6ce006ae7b08/bada4/1640138203_ESP32-UWB-Indoor-Positioning-Test-Makerfabs.jpg 153w,\n/static/f70ac99b7fb70463fa0c6ce006ae7b08/979a1/1640138203_ESP32-UWB-Indoor-Positioning-Test-Makerfabs.jpg 307w,\n/static/f70ac99b7fb70463fa0c6ce006ae7b08/7b087/1640138203_ESP32-UWB-Indoor-Positioning-Test-Makerfabs.jpg 613w","sizes":"(min-width: 613px) 613px, 100vw"},"sources":[{"srcSet":"/static/f70ac99b7fb70463fa0c6ce006ae7b08/eff8e/1640138203_ESP32-UWB-Indoor-Positioning-Test-Makerfabs.avif 153w,\n/static/f70ac99b7fb70463fa0c6ce006ae7b08/c2935/1640138203_ESP32-UWB-Indoor-Positioning-Test-Makerfabs.avif 307w,\n/static/f70ac99b7fb70463fa0c6ce006ae7b08/dd762/1640138203_ESP32-UWB-Indoor-Positioning-Test-Makerfabs.avif 613w","type":"image/avif","sizes":"(min-width: 613px) 613px, 100vw"},{"srcSet":"/static/f70ac99b7fb70463fa0c6ce006ae7b08/208eb/1640138203_ESP32-UWB-Indoor-Positioning-Test-Makerfabs.webp 153w,\n/static/f70ac99b7fb70463fa0c6ce006ae7b08/fa340/1640138203_ESP32-UWB-Indoor-Positioning-Test-Makerfabs.webp 307w,\n/static/f70ac99b7fb70463fa0c6ce006ae7b08/c01ad/1640138203_ESP32-UWB-Indoor-Positioning-Test-Makerfabs.webp 613w","type":"image/webp","sizes":"(min-width: 613px) 613px, 100vw"}]},"width":613,"height":368},"coverImageAlt":"Makerfabs UWB chip","datePublished":"2022-01-11T00:00:00.000Z","dateModified":"2022-01-11T00:00:00.000Z","category":"tech","tags":["programming","uwb","testing"],"excerpt":"ESP32 UWB Indoor Positioning Test ###Overview\n*1.1 Introduce\nDW1000 is the world's first single-chip wireless transceiver based on Ultra…","timeToRead":9,"slug":"/esp-32-uwb-indoor-positioning","route":"/blog/esp-32-uwb-indoor-positioning","pathName":"blog/esp-32-uwb-indoor-positioning","url":"https://zobo.dev/blog/esp-32-uwb-indoor-positioning"}]}},
    "staticQueryHashes": ["3661114550"]}